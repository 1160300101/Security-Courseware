# 隔离与沙箱


###哈尔滨工业大学 网络与信息安全 张宇 2016

参考课程: [MIT 6.858 Computer Systems Security](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/index.htm) 

---

本节课学习

##基于能力的安全

###糊涂副手问题

[访问控制（access control (AC)）](https://en.wikipedia.org/wiki/Access_control)：对资源消耗，访问，使用的的选择性限制。对访问资源的许可称为“授权（authorization）”。

[环境权威（ambient authority）](https://en.wikipedia.org/wiki/Ambient_authority)：这是目前操作系统所采用的主要访问控制形式，指权威在一个环境中被隐式行使。

访问请求只需要给出对象的名字和操作，是否允许操作依赖于执行程序的全局属性，如身份或角色。例如，C语言里`open("filename", O_RDONLY, 0)`，其中`filename`本身不具有权威信息，这个操作是否可行依赖于环境权威。

[糊涂副手问题（confused deputy problem）](https://en.wikipedia.org/wiki/Confused_deputy_problem)：在环境权威系统中，一个“糊涂”的特权程序被其他用户/程序“欺骗”来滥用其权利，导致特权扩大。

- 一个计算机安全例子：一个FORTRAN编译服务将用户指定的输入文件编译为指定的输出文件，并在一个账单文件中记录此次服务。一个恶意用户指定账单文件为输出文件来篡改账单，尽管该恶意用户并没有修改账单文件的权限。
- 一个现实安全例子：超市里一个小偷将一个商品的条形码替换成更便宜商品的条形码。“糊涂的收银员“被欺骗直接扫描条码，并按更便宜商品价格收款。小偷的特权被扩大，收银员的特权被滥用。


参考资料：[The Confused Deputy (or why capabilities might have been invented) (1988)](supplyments/The-Confused-Deputy.pdf)

###基于能力的安全

[基于能力（capability）的安全](https://en.wikipedia.org/wiki/Capability-based_security) ：一个能力是一个可交换但不可伪造的权威令牌（token），实现为一个引用(reference)指向一个受保护对象及相关访问权利（right）。

举例：

- `/etc/passwd` 是一个对象，但未说明权利
- `etc/passwd + O_RDWR ` 是一个带有权利说明的对象，但未说明用户进程是否可以合法访问这些值
- `int fd = open("/etc/passwd", O_RDWR);` 
	- 变量`fd`是在该进程文件描述表中的一个文件描述符索引
	- 文件描述符所在的文件描述表在内核内存中，不能被用户程序直接更改
	- 文件描述符说明该进程确实可合法访问对象，是一个能力

进程间共享能力：

- 对于前两个不是能力的例子，若在进程间传递这些信息，会导致糊涂副手问题
- 在基于能力的系统中，能力的传递需要操作系统来保证完整性

对于糊涂副手问题，一种解决方案是用户向编译服务传递输入/输出文件被打开的文件描述符，而不是文件名。文件描述符可以看做是用户能力的一个凭证。

对于超市收款问题，。

注意：Capability-based security不同于[POSIX/Linux capabilities](http://man7.org/linux/man-pages/man7/capabilities.7.html)，后者是对特权的细分。

---

##沙箱

[沙箱（sandbox）](https://en.wikipedia.org/wiki/Sandbox_(computer_security))：一种隔离运行程序的安全机制，常用于执行未测试或不可信程序，避免对操作系统或主机安全造成威胁，可被看做是虚拟化(virtualization)技术的一个特例。

- [jail](https://en.wikipedia.org/wiki/Operating-system-level_virtualization)：一种操作系统级虚拟化，例如[FreeBSD jail](https://en.wikipedia.org/wiki/FreeBSD_jail)，限制文件系统访问的chroot jail
- 容器：一种操作系统级虚拟化，利用Linux内核的资源分离机制实现独立应用容器，例如[LXC](https://en.wikipedia.org/wiki/LXC)和[Docker](https://en.wikipedia.org/wiki/Docker_(software))
- 基于规则的执行：通过一个明确的规则集来强制限制用户或程序访问（MAC），例如Linux安全模块（Linux Security Module，LSM）框架下的[SELinux](https://en.wikipedia.org/wiki/SELinux)和[Apparmor](https://en.wikipedia.org/wiki/Apparmor)
- [虚拟机](https://en.wikipedia.org/wiki/Virtual_machine)：模拟一个真实操作系统，客户机通过模拟器访问宿主机资源
- [capability](https://en.wikipedia.org/wiki/Capability-based_security)：通过token来表示程序所具备能力
- [seccomp (Secure Computing Mode)](https://en.wikipedia.org/wiki/Seccomp)：Linux内核中一种应用沙箱机制。在该模式下，进程只允许执行`exit()`, `sigreturn()`, 以及对已打开的文件描述符执行`read()` and `write()`, 而禁止其他系统调用
- [JVM（java virtual machines）](https://en.wikipedia.org/wiki/Java_virtual_machine)包括一个沙箱来运行不可信代码，例如Java applet

---

##Capsicum

参考资料：[Capsicum: practical capabilities for UNIX (USENIX Security 2010)](supplyments/Capsicum.pdf)

一种轻量级操作系统能力和沙箱框架（for FreeBSD9）

- 通过增加内核组件和用户空间库来扩展UNIX API
- 可逐渐修改应用程序来采用该框架
- 需要微内核体系和纯消息传递设计

###能力模式
- 通过新的`cap_enter`系统调用设置一个进程凭据标记
- 标记被所有后代进程继承，无法清除
- 能力模式的进程无法访问全局名字空间，例如文件系统和PID名字空间，以及若干系统管理接口（`/dev`, `ioctl`, `reboot`, `kldload`）
- 受限的系统调用（`sysctl`, `shm_open`）只允许创建匿名内存对象；只能操作给定文件描述符下的对象

### 能力
- 通过文件描述符（fd）表示
- fd是不可伪造的授权token, 可被子进程继承或IPC传递
- `cap_new`系统调用在一个存在的fd和一个权力（right）掩码上创建一个能力
- 能力的权力通过内核`fget`检查，该函数负责将fd参数转换为系统调用时内核中引用
- 能力通过fd作为`openat`等系统调用参数来传递，禁止绝对路径，“..”路径，`AT_FDCWD`
- 通过`fexecve`使用setuid和setgid来禁止特权提升

###运行时环境：
- 通过`libcapsicum`库API创建沙箱
- 通过`cap_enter`来切断对全局名字空间的访问
- 关闭为授权的文件描述符
- 通过`fexecve`来清洗地址空间
- 沙箱返回一个UNIX domain套接字用于与主机通信，或获得额外权利



---

##Native Client

参考资料：[Native Client: A Sandbox for Portable, Untrusted x86 Native Code (S&P 2009)](supplyments/nacl.pdf)

---

##Python沙箱实验

zoobar应用需要被扩展来支持‘可执行profile’，该扩展允许用户使用Python代码作为其profile。当其他用户浏览该用户的Python profile，服务器会执行其中的代码来生成profile输出。由此，用户可在profile中实现不同功能：

- 用用户名来欢迎访客
- 追踪最近几位访客
- 赠予每位访客一个zoobar（每分钟1个）

为安全支持这一功能需要在服务器上用沙箱来装载profile代码，使得profile代码不能执行任意操作或访问任意文件。这些代码需要跟踪一些文件中的持久化数据，或者访问存在的zoobar数据库。需要使用RPC库和一些现成的填充代码来将可执行代码沙箱化。

`profiles/`目录：

- `profiles/hello-user.py`是一个简单的profile，打印访客名字与当前时间
- `profiles/visit-tracker.py`跟踪每位访客最近一次查看profile的时间
- `profiles/last-visits.py`记录最后三个访客，并打印
- `profiles/xfer-tracker.py`打印profile拥有者和访客间最近一次交易
- `profiles/granter.py`给访客一个zoobar，条件是profile拥有者还有剩余的zoobar，访客的zoobar少于20，而且距离上次获得一个zoobar的时间至少一分钟

`zoobar/sanboxlib.py`是实现针对不可信profile的沙箱的模块。`Sandbox`类中`run()`方法执行沙箱中函数。`run`方法fork一个进程并在子进程中执行代码之前调用`setresuid`，令不可信代码没有任何特权。父进程从子进程读取输出，并返回给`run()`的调用者。若子进程在短时间内（5秒）未退出，则父进程杀死子进程。

`Sandbox.run`使用`chroot`来将不可信代码限制在指定目录，向`Sandbox`构造器传递一个参数。这允许不可信profile代码来形式一些有限的文件系统访问，但`Sandbox`的创建者来决定哪个目录能够被访问。

`Sandbox`只使用一个UID来运行不可信profile。为避免两个沙箱进程同时运行，使用了一个锁文件。当沙箱执行前，先锁定这个所文件，在沙箱进程退出后释放。若两个进程同时运行沙箱代码，只有一个进程会锁定文件。使用相同UID的所有用户应指定相同的所文件。

为阻止不可信代码fork其他进程，`Sandbox`使用Unix的资源限制机制：使用`setrlimit`来限制指定UID的进程数量，所以沙箱化代码不能fork。

`zoobar/profile-server.py`：一个RPC服务器接收运行某用户profile代码的请求，从执行代码中返回输出。

服务器使用`sandboxlib.py`来创建一个`Sandbox`，执行profile（通过`run_profile`函数）。`profile-server.py`创建一个RPC服务器来允许profile代码访问沙箱之外的对象，例如不同用户的zoobar余额。`ProfileAPIServer`实现这一接口；`profile-server.py`fork一个进程来运行`ProfileAPIServer`，将一个连接到服务器的RPC客户端传递给沙箱化代码。

因为`profile-server.py`使用`sandboxlib.py`，需要调用`setresuid`来沙箱化进程，所以主进程需要以root来运行。

若通过以一个不同UID来运行不可信代码来提高安全，必须以root来运行一部分代码。

将`profile-server.py`加入到`zook.conf`中，更改`chroot-setup.sh`来为其套接字创建一个目录`/jail/profilesvc`。`profile-server.py`需要以root运行，将`zook.conf`中UID设定为0.

- 更改`ProfileServer.rpc_run()`中`uid`从0到其他值
- 保证可以支持5个profile。需要调整`ProfileAPIServer`实现`rpc_get_xfers`或`rpc_xfer`。

运行`sudo make check`来测试，遇到问题时检查profiel输出`/tmp/html.out`以及服务器输出`/tmp/zookld.out`。

由于所有用户的profile访问相同文件，`ProfileServer.rpc_run()`设定`userdir`到`/tmp`，并传递给沙箱，一个用户profile可能损坏其他用户profile。

更改`profile-server.py`中`rpc_run`使得每个用户profile只能访问自己的文件，不能篡改其他用户文件。

更改`profile-server.py`中`ProfileAPIServer`来避免其以root运行。在`ProfileAPIServer.__init__`，切换到不同UID。

